# 跳跃游戏Ⅱ

题目：给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置在下标 0。

每个元素 `nums[i]` 表示从索引 `i` 向后跳转的最大长度。换句话说，如果你在索引 `i` 处，你可以跳转到任意 `(i + j)` 处：

- `0 <= j <= nums[i]` 且
- `i + j < n`

返回到达 `n - 1` 的最小跳跃次数。测试用例保证可以到达 `n - 1`。



思考：简单理解一下其实就是利用最小的跳数的次数，通过在每个点上提供的 j 跳距的增加，来到达最后一个节点

例如：

```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

简单理解就是，首先我们在索引0的节点上，该节点提供了跳距为2，支持我们跳到索引1和索引2的位置上，这两个位置的分别提供了跳距3和1，在索引为1的位置上，我们可以跳到索引1+3的位置，在索引为2的位置上，我们可以跳到索引2+1的位置，这个最终的落点位置其实就是（索引下标i+提供的跳距j）

所以最快到达最后节点的方法就是，让索引下标+提供的跳距尽可能的大，先假设现在的跳跃到的位置在索引now_point，然后假设下一次的位置为next_point，如果now_point的位置等于现在索引的位置，则说明需要跳跃了，当下一次跳跃能跳出最后的索引位置，则说明下一次必定能到达，这时候我们就完成了简单的逻辑构建。

接下来是一些边界条件：

比如我们要考虑要遍历多少个节点，我们只需要考虑要走多少步就能到达最后一个节点，所以我们是不用再最后一个节点上再走一步的，所以总共的遍历次数是（总长度-1），因为节点索引是从零开始的，所以是（总长度-1-1）

接下来我们就可以很简单的写出代码：

```python
def jump(self, nums: List[int]) -> int:
    ans = 0
    now_point = 0
    next_point = 0
    # 将nums上提供的索引位置i和跳距j提取出来
    for i,j in enumerate(nums):
        # 使得下一次跳跃的距离尽可能的大
        next_point = max(next_point,i+j)
        # 现在索引位置已经到达我们第一次跳跃的最长的位置了，必须再跳一次
        if i == now_point:
            now_point = next_point
        	ans+=1
    return ans
    
```

