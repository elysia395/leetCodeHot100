# 两数之和--题目重述
给定一个整数数组 `nums` 和一个整数目标值 `target`，
请你在该数组中找出和为目标值 `target` 的那两个整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。
你可以按任意顺序返回答案。

实际上也就是遍历数组中的每一个元素，计算并且检查差值是否重复出现

## 解题思路--暴力法（好早之前做的了）
暴力循环遍历数组中的每一个元素，计算并且检查差值是否重复出现。

## 解题思路--hashmap
通过哈希表来存储已经遍历过的数字及其索引，这样可以在一次遍历中找到答案。

## 代码实现
```java
import java.util.HashMap;
import java.util.Map;

public class Solution {
    public int[] twoSum(int[] nums, int target) {
        // 创建一个哈希表来存储值和索引
        Map<Integer, Integer> numMap = new HashMap<>();

        // 遍历数组
        for (int i = 0; i < nums.length; i++) {
            int num = nums[i];
            // 计算差值
            int complement = target - num;

            // 检查差值是否在哈希表中
            if (numMap.containsKey(complement)) {
                // 如果在，返回当前索引和哈希表中存储的索引
                return new int[]{numMap.get(complement), i};
            }

            // 如果不在，将当前值和索引存入哈希表
            numMap.put(num, i);
        }

        // 如果没有找到，返回空数组（根据题目描述，应该总是有解）
        return new int[0];
    }
}
```

## 复杂度分析
- 时间复杂度：O(n)，其中 n 是数组的长度。我们只需要遍历一次数组。
- 空间复杂度：O(n)，最坏情况下需要存储 n 个键值对在哈希表中。
