# 打家劫舍

题干：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。



思路：其实是求最大的不相邻的数组合，我们可以分为奇，偶链来分析，奇数索引的总数据和偶数索引的总数据

分析：如何在最短的时间消耗和最少的空间消耗下完成这个步骤

最短时间消耗，O(n)即一次循环，最小的空间消耗O(1),只需几个简单变量

要满足最短时间消耗其实相对简单，因为我们一次for循环就能完成整个nums数组的遍历了，难点在最小的空间消耗，如何通过简单的变量来完成不断增长的奇偶链

如果开始索引是0，下个索引就是1，那么我们可以知道其实奇数链和偶数链是交替关系，如果按索引0，1，2，....这样的顺序，新的奇数链其实是旧的奇数链+新的位置的数，

我们可以假设两个变量f0和f1，**相互交替存储**奇数链和偶数链，注意理解这个相互交替存储，当新f1是奇数链的时候，新f0应该是偶数链，但是老f1其实是偶数链，老f0是奇数链条，所以可以通过老f0来计算新f1，老f1其实就是新f0，因为f1，f0在同一阶段下，f1在f0前面，所以下一阶段f0就等于f1了。

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

通过示例演示一下我的思路，先假设f0，f1都没出发，都为0。接下来f1先向前走，到达索引0的位置，f1被赋值为1，f0被赋值为0，接下来继续往下走到索引1的位置，变为奇数链，新f1为旧f0加上新位置索引1的大小，f1被赋值为0+2，而新f0往前走，继承旧f1的大小被赋值为1；继续往下走f1走到索引2的位置，f1被赋值为3+f0 = 3 + 1 = 4（因为要求最大数字合的链，所以这里可以和前一个f1比较一下大小，只保留最大的f1），然后就是接着f0继承旧f1，f0被赋值为2....

现在理清楚了思路，来完成代码部分：

```python
def rob(self, nums: List[int]) -> int:
    f0 = f1 = 0
    # 使用_用来忽略到key，用x接收nums的value值
    for _,x in enmuerate(nums):
       	# 同时完成f0继承旧f1和f1往下走的操作
        f0,f1 = f1, max(f1,f0+x)
    return f1
        
    
```

