# 乘积最大子数组--题目重述
给你一个整数数组 `nums`，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字） ，
并返回该子数组所对应的乘积。测试用例的答案是一个 32-位 整数。

子数组--指数组中一个或多个连续的元素组成的序列（要求必须连续，并且长度不限只要不为0就可以）
## 解题思路--双向遍历的连乘算法
（1）如何实现寻找子数组并且要找全？
   --> 通过双向遍历，从左到右遍历一次，从右到左遍历一次，确保不会漏掉可能的子数组最大组合情况
（2）因为子数组长度是不定的，怎么保证找到的数字一定是最大的呢？
   --> 代码通过连续乘积的算法，每一次进位都会保留前数字，也就是说，算法保留了每一次循环进位的最大值可能，并且通过max()
       函数比较器进行比较，确保最大值能够正常更新或保留。
   --> 同时，不可避免的是原始数组中可能会出现0的情况，0在连乘的情况下会始终导致结果为0，通过两次比较确保有正数的情况下，
       将遇0情况重置。

### 代码实现
```java
public class Solution3 {
   public int maxProduct(int[] nums) {
      // 检查数组是否为空或长度为0
      if (nums == null || nums.length == 0) {
         return 0;
      }
      int n = nums.length;  // 获取数组长度
      int max = nums[0];    // 初始化最大乘积为第一个元素

      int product = 1;     // 初始化乘积为1
      // 从左到右遍历数组
      for (int i = 0; i < n; i++) {
         product = product * nums[i];  // 计算当前乘积
         max = Math.max(max, product); // 更新最大乘积
         // 如果遇到0，重置乘积为1（因为0会使得后续乘积为0）
         if (nums[i] == 0){
            product = 1;
         }
      }
      product = 1;         // 重置乘积为1
      // 从右到左遍历数组
      for (int i = n-1; i >= 0; i--) {
         product = product * nums[i];  // 计算当前乘积
         max = Math.max(max, product); // 更新最大乘积
         // 如果遇到0，重置乘积为1（因为0会使得后续乘积为0）
         if (nums[i] == 0){
            product = 1;
         }
      }
      return max;  // 返回最大乘积

   }
}
```
**复杂度**：
- 时间复杂度：O(n)