# 分割回文串

题目：给你一个字符串 `s`，请你将 `s` 分割成一些 子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

思路：首先是想到需要判断回文串，这块比较简单，就是反转一下字符串，然后和先前的进行比较。接下来就是分割字符串长度的确定，这里可以遍历初始位置到（len(s)-1），来得到结束位置，然后判断是否是回文串，如果是的话，则加入到结果中，然后我们要进入到下一个字符串的分割，是不是就是进入到了递归的循环，要层层递归下去，每一次分割都和上面的过程一致，先从开始位置遍历，然后判断，然后继续进行递归，直到最后的位置到末尾字符。

**示例 1：**

```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

首先从a开始，结束的位置可以是索引0，索引1，也可以是索引2，然后先判断当结束位置在索引0的时候，这个时候是单字符，一定是回文串，可以进行分割，输入单独“a”，然后进入递归，从索引1继续，索引1的结束位置可以是索引1，也可以是索引2。但是索引2不满足回文...以此类推。

当从索引最后一个的时候此时递归结束了，不需要判断最后一个了，因为单字符一定是回文。返回结果。

这时候递归结束，我们要复原一开始存入的，回到开始的索引0的位置，然后从结束位置为2的地方继续递归进入。

理清楚思路，来进行代码的撰写

```python
def partition(self, s: str) -> List[List[str]]:
    n = len(s)
    ans = []
    path = []
    def dfs(i:int) -> None:
        # 已经到达最后的位置，将结果复制入ans列表中
        if i == s:
            ans.append(path[:])
            return
        for j in range(i,n):
            t = s[i:j+1]
            # 判断是否是回文串
            if t ==t[::-1]:
                path.append(t)
                # 下一个字符串的开始位置
                dfs(j+1)
                # 记得当递归结束的时候，应该恢复path
                path.pop()
        dfs(0)
        return ans
```