# 括号生成

题目：数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

思路：首先判断什么是有效的括号组合，即不是孤立的"(" ，")“。用人话描述就是首先不可能出现"("的数量和")"的数量不一致，同时每个“(”都需要与一个“）”相联系，也就是“)"不可能先于其相联系的“(”先出现

那我们在考虑回溯+递归的时候，就需要先选"("再考虑选“)”,当“(”和“)”的数量和为2n的时候完成括号的生成组合

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

简单理解，如果右括号的数量等于n括号的对数，这时候就可以把结果返回了，然后就是构建这个组合的过程：回溯的依据就是选左括号还是选右括号，如果选左括号，则带着结果进入递归，如果选右括号则带着右括号的结果进入递归

```python
def generateParenthesis(self, n: int) -> List[str]:
    # 总共的括号组合
    ans = []
    # 一个括号组合
    path = ['']*(n*2)
    def dfs(left:int,right:int) -> None:
        if right == n:
            ans.append(''.join(path))
            return
        if left < n:
            # 这个left + right 总和，就是现在存储进去的下标
            path[left+right] = '('
            dfs(left + 1,right)
        if right < left:
            path[left+right] = ')'
            dfs(left,right + 1)
    dfs(0,0)
    return ans
```

