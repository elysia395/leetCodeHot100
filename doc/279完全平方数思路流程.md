# 问题-279完全平方数
    给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。 
    完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
## 问题重述
    给定一个整数n，求n的最小完全平方数个数
    由于1的平方始终等于1，理论上任何数都可以被解析为完全平方数之和的形式；
    n=5，可以解析为1+1+1+1+1，也可以解析为1+4，所以n=5的最小完全平方数个数为2。也就是实现遍历找到最简形式
### 思路过程（遍历-贪心-动态规划）
    1.递归求解
      递归求解很暴力，每一次迭代，一定能求出最终解，但是存在浪费性能的问题。
    2.贪心算法
      贪心算法，每一次迭代，都选择最大的完全平方数，但是在某些情况下无法解出最优解
      本题中，在进行leetocode测试时发现：当输入为12，算法所给出解为4，而非最优解3
    3.动态规划
      动态规划，每一次迭代，都选择最小的完全平方数。
### 时间复杂度比较
    动态规划：空间复杂度为O(n)，需要存储dp数组。
    贪心算法：空间复杂度为O(√n)，主要用于存储完全平方数列表。
#### 代码解决1--贪心
public class Solution2 {
    public int numSquares(int n) {
    List<Integer> squareNumbers = new ArrayList<>();// 生成所有小于等于n的完全平方数
    for (int i = 1; i * i <= n; i++) {
        squareNumbers.add(i * i);
    }
        return greedyHelper(n, squareNumbers, 0);
    }
    private int greedyHelper(int n, List<Integer> squareNumbers, int count) {
        // 基本情况：如果n为0，返回当前计数
        if (n == 0) {
            return count;
        }
        // 从大到小遍历完全平方数
        for (int i = squareNumbers.size() - 1; i >= 0; i--) {
            int square = squareNumbers.get(i);
            if (square <= n) {
                int maxCount = n / square;// 尽可能多地使用当前最大的完全平方数
                // 递归处理剩余部分
                int result = greedyHelper(n - maxCount * square, squareNumbers, count + maxCount);
                if (result != -1) {
                    return result;
                }
            }
        }
        return 0;
    }
}
#### 代码解决2--动态规划 ai
public class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];  // 创建一个长度为n+1的dp数组，dp[i]表示组成数字i所需的最少完全平方数数量
// 初始化dp数组，dp[0] = 0，因为0不需要任何完全平方数组成 ，其他位置初始化为最大值n（因为最坏情况下，全由1组成）
        for (int i = 1; i <= n; i++) {
            dp[i] = i; // 最坏情况：全部由1组成
            }
// 动态规划填充dp数组
        for (int i = 1; i <= n; i++) {
            // 遍历所有可能的完全平方数
            for (int j = 1; j * j <= i; j++) {
                dp[i] = Math.min(dp[i], dp[i - j * j] + 1); // 更新dp[i]：取当前值和dp[i - j*j] + 1中的较小值
            }
        }
        return dp[n];
    }
}


